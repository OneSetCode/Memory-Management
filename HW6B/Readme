// Zicheng Niu, https://gitlab.cs.washington.edu/cse374-23sp-students/cse374-23sp-niuzc/-/tree/main/HW6B

// The freelist data structure is managed by getmem and freemem functions. It is an ordered linked list order by memory address.

   When calling the getmem function, it will search in order on the freelist to find the first block that is large enough for 
   the required memory size. When found, it will check whether the block is too large for the required size. If no, return it directly. 
   If yes, it will split the block, return the reduced block, and put the remaining block back to the freelist in its original place.
   If getmem can't find the appropiate block, it will use malloc to allocate a new block of memory. Again, if the block is too large, 
   getmem will split the block, return the reduced block, and add the remaining block to the freelist in the right place according to 
   its address. If no, return directly.

   When calling the freemem function, it will first move the pointer back by NODESIZE to obtain the true start of the block and the size
   of the block. Then it will find the right place on the freelist for the block. Then it will check whether the returned block is physically 
   adjacent to its previous or next block according to their address and sizes. If yes, it will merge the blocks that are adjacent. If no, 
   it will directly add the block to the right place.

// The observed results shows that it requires a little more time than using memory.o, a little more bytes of memory are acquired, and the 
   average number of bytes in the free storage blocks are similar to the memory.o.

// The resources I consulted for information are mostly Google.
  